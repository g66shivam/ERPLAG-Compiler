// BATCH NUMBER 30
// SHIVAM GUPTA 2014A7PS066P
// PULKIT GUPTA 2014A7PS157P

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "codegen.h"
#include "symbolTable.h"

int main(int argc, char const *argv[])
{ 
	int in;
	FILE *fp;
	char *line = NULL;
	size_t len = 0;
	printf("\n\n\n");			
	puts("LEVEL 4: Symbol table / AST Generation / type Checking / Semantic Rules / Code Generation modules work");
	printf("\t\tPress option for the defined task\n");
	printf("1 : For printing the token list generated by the lexer:\n");
	printf("2 : For parsing to verify the syntactic correctness of the input source code and to produce parse tree\n");
	printf("3 : For printing the Abstract Syntax Tree in appropriate format. Also specify the traversal order at the beginning\n");
	printf("4 : For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used\n");
	printf("5 : For printing the Symbol Table in appropriate format showing all relevant information\n");
	printf("6 : For compiling to verify the syntactic and semantic correctness of the input source code\n");
	printf("7 : For producing assembly code\n");
	scanf("%d",&in);
	switch(in)
	{
		case 1:
				read_symbolTable();
				fp = fopen(argv[1],"r");
				removeComments(fp);
				fclose(fp);
				fp = fopen("cleanFile.txt","r");
				getStream(fp);
				fclose(fp);
 				printT();
 				break;
		// OK
		case 2:
				read_symbolTable();
 				fp = fopen(argv[1],"r");
 				removeComments(fp);
 				fclose(fp);
 				fp = fopen("cleanFile.txt","r");
 				getStream(fp);
 				fclose(fp);
    			Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error==0)
				{
					printf("Code is syntactically correct\n");
					printParseTree(parseTree_head,1,1);
					//printf("NODES IN PT %d\n",nodes_par);
				}
				else
				{
					printf("Code is syntactically not correct & hence parse tree can't be printed\n");
				}
				break;
 		// OK
 		case 3:
 				read_symbolTable();
				fp = fopen(argv[1],"r");
				removeComments(fp);
				fclose(fp);
				fp = fopen("cleanFile.txt","r");
				getStream(fp);
				fclose(fp);
				Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error == 0)
				{
					puts("INORDER traversal of AST follows:");
					make_ast(parseTree_head);
					printParseTree(parseTree_head,2,1);
					//printf("NODES IN AST %d\n",nodes_ast);
				}
				else
				{
					puts("INORDER traversal of AST follows:");
					puts("There are syntactic errors in code, hence can't generate AST");
				}
				break;
		// OK
		case 4:
 				read_symbolTable();
				fp = fopen(argv[1],"r");
				removeComments(fp);
				fclose(fp);
				fp = fopen("cleanFile.txt","r");
				getStream(fp);
				fclose(fp);
				Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error == 0)
				{
					printParseTree(parseTree_head,1,0);
					make_ast(parseTree_head);
					printParseTree(parseTree_head,2,0);
					printf("Parse tree     Number of nodes = %d Allocated Memory = %lu Bytes\n",nodes_par,nodes_par*sizeof(node));
					printf("AST            Number of nodes = %d Allocated Memory = %lu Bytes\n",nodes_ast,nodes_ast*sizeof(node));
					printf("Compression percentage = %lf\n",(nodes_par-nodes_ast)*100.0/nodes_par);
				}
				else
				{
					printf("Code is syntactically not correct & hence parse tree and AST can't be constructed\n");
				}
				break;
		// OK
		case 5:
				read_symbolTable();
				fp = fopen(argv[1],"r");
				removeComments(fp);
				fclose(fp);
				fp = fopen("cleanFile.txt","r");
				getStream(fp);
				fclose(fp);
				Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error == 0)
				{	
					build_symbol_table(parseTree_head);
					printf("s.no.  identifier  type                module_name  line_number  nesting  width  offset\n");	
					print_symbol_table(parseTree_head);
				}
				else
				{
					puts("Symbol Table can't be printed since there are synatactical errors");
				}
				break;
	   case 6:
				read_symbolTable();
				fp = fopen(argv[1],"r");
				removeComments(fp);
				fclose(fp);
				fp = fopen("cleanFile.txt","r");
				getStream(fp);
				fclose(fp);
				Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error == 0)
				{	
					puts("No Synatactic Errors");
					puts("Semantic errors, if any follow:");
					build_symbol_table(parseTree_head);
					deficit_errors();
					print_sym_table_errors();	
					make_ast(parseTree_head);
					type_checker(parseTree_head);
					semantic_analyzer(parseTree_head);
					if(semantic_error == 0)
						puts("Code compiles successfully..........\n");
				}
				break;
		case 7: 
				
				read_symbolTable();
 				fp = fopen(argv[1],"r");
 				removeComments(fp);
 				fclose(fp);
 				fp = fopen("cleanFile.txt","r");
 				getStream(fp);
 				fclose(fp);
    			Read_Grammar();
				createParseTable();
				parseInputSourceCode();
				if(error==0){
					build_symbol_table(parseTree_head);
					deficit_errors();
					//print_sym_table_errors();	
					make_ast(parseTree_head);
					type_checker(parseTree_head);
					semantic_analyzer(parseTree_head);
					
					if(semantic_error==0)
					{
						freopen(argv[2],"w",stdout);
						printf("global main\nextern printf\nextern scanf\nextern puts\nsection .data\nMEM: times 1000 db 0\narr:  times 2 db 0\nmen:  db \"Value is %%d \",10,0\ninputFormat: db \"%%d\",10,0\nvar: times 8 db 0\n\nsection .text\nmain:\n\n");
						code_generator(parseTree_head);
					}
					else
						printf("Semantic Errors Detected...Cant proceed with Code Generation\n");
				}
				break;
		default:
				printf("Please enter a suitable option\n");
	}
	return 0;
}
